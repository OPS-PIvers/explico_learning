<script>
/**
 * HotspotManager Service for Explico Learning
 * Manages hotspot CRUD operations, state synchronization, and component coordination
 */

class HotspotManager {
  
  constructor(options = {}) {
    this.options = {
      autoSave: true,
      validateOnUpdate: true,
      maxHotspots: UI_CONFIG.MAX_HOTSPOTS_PER_SLIDE,
      ...options
    };
    
    this.hotspots = new Map(); // Map<slideId, Map<hotspotId, hotspotData>>
    this.activeSlideId = null;
    this.selectedHotspotId = null;
    this.eventListeners = new Map();
    this.changeQueue = [];
    this.isProcessingChanges = false;
    
    // Component references
    this.canvas = null;
    this.configPanel = null;
    this.sequencer = null;
    
    // Services
    this.sheetsAPI = null;
    this.eventTypeHandlers = null;
  }
  
  /**
   * Initialize the hotspot manager
   * @param {Object} dependencies - Service dependencies
   */
  initialize(dependencies = {}) {
    this.sheetsAPI = dependencies.sheetsAPI;
    this.eventTypeHandlers = dependencies.eventTypeHandlers;
    
    // Set up auto-save if enabled
    if (this.options.autoSave) {
      this.setupAutoSave();
    }
  }
  
  /**
   * Set component references for coordination
   * @param {Object} components - Component instances
   */
  setComponents(components = {}) {
    this.canvas = components.canvas;
    this.configPanel = components.configPanel;
    this.sequencer = components.sequencer;
    
    this.setupComponentEventHandlers();
  }
  
  /**
   * Set up component event handlers
   */
  setupComponentEventHandlers() {
    if (this.canvas) {
      this.canvas.hotspotRenderer.setEventHandlers({
        onHotspotCreate: (config) => this.createHotspot(config),
        onHotspotSelect: (id) => this.selectHotspot(id),
        onHotspotUpdate: (id, updates) => this.updateHotspot(id, updates),
        onPositionChange: (id, position) => this.updateHotspotPosition(id, position)
      });
    }
    
    if (this.configPanel) {
      this.configPanel.options.onConfigChange = (property, value, hotspot) => {
        this.updateHotspot(hotspot.id, { [property]: value });
      };
    }
    
    if (this.sequencer) {
      this.sequencer.options.onHotspotReorder = (fromIndex, toIndex, hotspot) => {
        this.reorderHotspot(hotspot.id, fromIndex, toIndex);
      };
    }
  }
  
  /**
   * Set active slide
   * @param {string} slideId - Slide ID
   */
  setActiveSlide(slideId) {
    if (this.activeSlideId === slideId) return;
    
    // Save any pending changes for current slide
    this.processPendingChanges();
    
    this.activeSlideId = slideId;
    this.selectedHotspotId = null;
    
    // Initialize hotspots map for slide if doesn't exist
    if (!this.hotspots.has(slideId)) {
      this.hotspots.set(slideId, new Map());
    }
    
    // Update components
    this.syncComponentsWithSlide(slideId);
    
    // Emit event
    this.emit('slideChanged', { slideId, hotspots: this.getSlideHotspots(slideId) });
  }
  
  /**
   * Create a new hotspot
   * @param {Object} config - Hotspot configuration
   * @returns {Promise<Object>} Created hotspot
   */
  async createHotspot(config = {}) {
    if (!this.activeSlideId) {
      throw new Error('No active slide set');
    }
    
    const slideHotspots = this.hotspots.get(this.activeSlideId);
    
    // Check maximum hotspots limit
    if (slideHotspots.size >= this.options.maxHotspots) {
      throw new Error(`Maximum ${this.options.maxHotspots} hotspots allowed per slide`);
    }
    
    // Generate ID if not provided
    const hotspotId = config.id || this.generateHotspotId();
    
    // Create hotspot with defaults
    const hotspot = {
      ...HOTSPOT_DEFAULTS,
      ...config,
      id: hotspotId,
      slideId: this.activeSlideId,
      order: slideHotspots.size,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    // Validate hotspot
    if (this.options.validateOnUpdate) {
      this.validateHotspot(hotspot);
    }
    
    // Add to local storage
    slideHotspots.set(hotspotId, hotspot);
    
    // Update components
    this.syncHotspotToComponents(hotspot, 'create');
    
    // Queue for auto-save
    this.queueChange('create', hotspot);
    
    // Emit event
    this.emit('hotspotCreated', hotspot);
    
    return hotspot;
  }
  
  /**
   * Update hotspot configuration
   * @param {string} hotspotId - Hotspot ID
   * @param {Object} updates - Updates to apply
   * @returns {Promise<Object>} Updated hotspot
   */
  async updateHotspot(hotspotId, updates = {}) {
    const hotspot = this.getHotspot(hotspotId);
    if (!hotspot) {
      throw new Error(`Hotspot ${hotspotId} not found`);
    }
    
    const previousState = { ...hotspot };
    
    // Apply updates
    Object.assign(hotspot, updates, {
      updatedAt: new Date().toISOString()
    });
    
    // Validate updated hotspot
    if (this.options.validateOnUpdate) {
      this.validateHotspot(hotspot);
    }
    
    // Update components
    this.syncHotspotToComponents(hotspot, 'update');
    
    // Queue for auto-save
    this.queueChange('update', hotspot, previousState);
    
    // Emit event
    this.emit('hotspotUpdated', { hotspot, previousState, updates });
    
    return hotspot;
  }
  
  /**
   * Update hotspot position (optimized for drag operations)
   * @param {string} hotspotId - Hotspot ID
   * @param {Object} position - New position {x, y}
   */
  updateHotspotPosition(hotspotId, position) {
    const hotspot = this.getHotspot(hotspotId);
    if (!hotspot) return;
    
    hotspot.position = { ...position };
    hotspot.updatedAt = new Date().toISOString();
    
    // Update canvas immediately (no validation needed for position)
    if (this.canvas) {
      this.canvas.updateHotspot(hotspotId, { position });
    }
    
    // Debounced save for position changes
    this.debouncedSave(hotspotId);
    
    // Emit event
    this.emit('hotspotPositionChanged', { hotspotId, position });
  }
  
  /**
   * Delete a hotspot
   * @param {string} hotspotId - Hotspot ID
   * @returns {Promise<boolean>} Success status
   */
  async deleteHotspot(hotspotId) {
    const hotspot = this.getHotspot(hotspotId);
    if (!hotspot) {
      throw new Error(`Hotspot ${hotspotId} not found`);
    }
    
    const slideHotspots = this.hotspots.get(this.activeSlideId);
    
    // Remove from local storage
    slideHotspots.delete(hotspotId);
    
    // Update order of remaining hotspots
    this.reorderHotspots();
    
    // Clear selection if this hotspot was selected
    if (this.selectedHotspotId === hotspotId) {
      this.selectHotspot(null);
    }
    
    // Update components
    this.syncHotspotToComponents(hotspot, 'delete');
    
    // Queue for auto-save
    this.queueChange('delete', hotspot);
    
    // Emit event
    this.emit('hotspotDeleted', hotspot);
    
    return true;
  }
  
  /**
   * Select a hotspot for editing
   * @param {string} hotspotId - Hotspot ID (null to deselect)
   */
  selectHotspot(hotspotId) {
    const previousSelection = this.selectedHotspotId;
    
    if (hotspotId && !this.getHotspot(hotspotId)) {
      console.warn(`Hotspot ${hotspotId} not found, cannot select`);
      return;
    }
    
    this.selectedHotspotId = hotspotId;
    
    // Update components
    if (this.canvas) {
      this.canvas.selectHotspot(hotspotId);
    }
    
    if (this.configPanel) {
      const hotspot = hotspotId ? this.getHotspot(hotspotId) : null;
      this.configPanel.setHotspot(hotspot);
    }
    
    if (this.sequencer) {
      const hotspots = this.getSlideHotspots(this.activeSlideId);
      const index = hotspots.findIndex(h => h.id === hotspotId);
      if (index !== -1) {
        this.sequencer.setCurrentIndex(index);
      }
    }
    
    // Emit event
    this.emit('hotspotSelectionChanged', {
      selectedId: hotspotId,
      previousId: previousSelection,
      hotspot: hotspotId ? this.getHotspot(hotspotId) : null
    });
  }
  
  /**
   * Reorder hotspot in sequence
   * @param {string} hotspotId - Hotspot ID
   * @param {number} fromIndex - Source index
   * @param {number} toIndex - Target index
   */
  reorderHotspot(hotspotId, fromIndex, toIndex) {
    const hotspots = this.getSlideHotspots(this.activeSlideId);
    
    if (fromIndex < 0 || toIndex < 0 || fromIndex >= hotspots.length || toIndex >= hotspots.length) {
      return;
    }
    
    // Update order values
    const reorderedHotspots = [...hotspots];
    const [movedHotspot] = reorderedHotspots.splice(fromIndex, 1);
    reorderedHotspots.splice(toIndex, 0, movedHotspot);
    
    // Update order property for all hotspots
    reorderedHotspots.forEach((hotspot, index) => {
      hotspot.order = index;
      hotspot.updatedAt = new Date().toISOString();
    });
    
    // Update components
    this.syncSequencerWithHotspots(reorderedHotspots);
    
    // Queue for auto-save
    this.queueChange('reorder', { hotspots: reorderedHotspots });
    
    // Emit event
    this.emit('hotspotsReordered', { fromIndex, toIndex, hotspots: reorderedHotspots });
  }
  
  /**
   * Get hotspot by ID
   * @param {string} hotspotId - Hotspot ID
   * @returns {Object|null} Hotspot data
   */
  getHotspot(hotspotId) {
    if (!this.activeSlideId) return null;
    const slideHotspots = this.hotspots.get(this.activeSlideId);
    return slideHotspots ? slideHotspots.get(hotspotId) : null;
  }
  
  /**
   * Get all hotspots for a slide
   * @param {string} slideId - Slide ID
   * @returns {Array} Array of hotspot objects
   */
  getSlideHotspots(slideId) {
    const slideHotspots = this.hotspots.get(slideId);
    if (!slideHotspots) return [];
    
    return Array.from(slideHotspots.values())
      .sort((a, b) => (a.order || 0) - (b.order || 0));
  }
  
  /**
   * Get selected hotspot
   * @returns {Object|null} Selected hotspot
   */
  getSelectedHotspot() {
    return this.selectedHotspotId ? this.getHotspot(this.selectedHotspotId) : null;
  }
  
  /**
   * Load hotspots for a slide from storage
   * @param {string} slideId - Slide ID
   * @returns {Promise<Array>} Loaded hotspots
   */
  async loadSlideHotspots(slideId) {
    if (!this.sheetsAPI) {
      console.warn('GoogleSheetsAPI not available, using local storage only');
      return this.getSlideHotspots(slideId);
    }
    
    try {
      const hotspots = await this.sheetsAPI.getHotspotsBySlide(slideId);
      
      // Store in local cache
      const slideHotspotsMap = new Map();
      hotspots.forEach(hotspot => {
        slideHotspotsMap.set(hotspot.id, hotspot);
      });
      this.hotspots.set(slideId, slideHotspotsMap);
      
      // Update components if this is the active slide
      if (slideId === this.activeSlideId) {
        this.syncComponentsWithSlide(slideId);
      }
      
      return hotspots;
    } catch (error) {
      console.error('Failed to load hotspots from sheets:', error);
      return this.getSlideHotspots(slideId);
    }
  }
  
  /**
   * Save hotspots to storage
   * @param {string} slideId - Slide ID (optional, defaults to active slide)
   * @returns {Promise<boolean>} Success status
   */
  async saveSlideHotspots(slideId = null) {
    const targetSlideId = slideId || this.activeSlideId;
    if (!targetSlideId) return false;
    
    if (!this.sheetsAPI) {
      console.warn('GoogleSheetsAPI not available, changes saved locally only');
      return true;
    }
    
    try {
      const hotspots = this.getSlideHotspots(targetSlideId);
      await this.sheetsAPI.saveHotspots(hotspots);
      
      // Clear change queue for this slide
      this.changeQueue = this.changeQueue.filter(change => 
        change.data.slideId !== targetSlideId
      );
      
      return true;
    } catch (error) {
      console.error('Failed to save hotspots to sheets:', error);
      return false;
    }
  }
  
  /**
   * Validate hotspot configuration
   * @param {Object} hotspot - Hotspot to validate
   * @throws {Error} If validation fails
   */
  validateHotspot(hotspot) {
    const errors = [];
    
    // Required fields
    if (!hotspot.id) errors.push('Hotspot ID is required');
    if (!hotspot.slideId) errors.push('Slide ID is required');
    if (!hotspot.name || hotspot.name.trim().length === 0) {
      errors.push('Hotspot name is required');
    }
    
    // Name length validation
    const nameRule = VALIDATION_RULES.HOTSPOT_NAME;
    if (hotspot.name && hotspot.name.length > nameRule.maxLength) {
      errors.push(`Hotspot name must be ${nameRule.maxLength} characters or less`);
    }
    
    // Position validation
    if (!hotspot.position || typeof hotspot.position.x !== 'number' || typeof hotspot.position.y !== 'number') {
      errors.push('Valid position coordinates are required');
    }
    
    // Size validation
    if (hotspot.size && (hotspot.size < 16 || hotspot.size > 100)) {
      errors.push('Hotspot size must be between 16 and 100 pixels');
    }
    
    // Event type specific validation
    if (hotspot.eventType) {
      switch (hotspot.eventType) {
        case EVENT_TYPES.TEXT_ON_IMAGE:
        case EVENT_TYPES.TEXT_POPUP:
          if (!hotspot.tooltipContent || hotspot.tooltipContent.trim().length === 0) {
            errors.push('Tooltip content is required for text events');
          }
          break;
        
        case EVENT_TYPES.PAN_ZOOM:
          if (hotspot.zoomLevel && (hotspot.zoomLevel < UI_CONFIG.MIN_ZOOM_LEVEL || hotspot.zoomLevel > UI_CONFIG.MAX_ZOOM_LEVEL)) {
            errors.push(`Zoom level must be between ${UI_CONFIG.MIN_ZOOM_LEVEL} and ${UI_CONFIG.MAX_ZOOM_LEVEL}`);
          }
          break;
      }
    }
    
    if (errors.length > 0) {
      throw new Error(`Hotspot validation failed: ${errors.join(', ')}`);
    }
  }
  
  /**
   * Sync hotspot to components
   * @param {Object} hotspot - Hotspot data
   * @param {string} action - Action type (create, update, delete)
   */
  syncHotspotToComponents(hotspot, action) {
    if (this.canvas) {
      switch (action) {
        case 'create':
          this.canvas.addHotspot(hotspot);
          break;
        case 'update':
          this.canvas.updateHotspot(hotspot.id, hotspot);
          break;
        case 'delete':
          this.canvas.removeHotspot(hotspot.id);
          break;
      }
    }
    
    if (this.sequencer && this.activeSlideId) {
      const hotspots = this.getSlideHotspots(this.activeSlideId);
      this.sequencer.setHotspots(hotspots);
    }
    
    if (this.configPanel && this.selectedHotspotId === hotspot.id) {
      this.configPanel.setHotspot(action === 'delete' ? null : hotspot);
    }
  }
  
  /**
   * Sync components with slide hotspots
   * @param {string} slideId - Slide ID
   */
  syncComponentsWithSlide(slideId) {
    const hotspots = this.getSlideHotspots(slideId);
    
    if (this.canvas) {
      this.canvas.setHotspots(hotspots);
    }
    
    if (this.sequencer) {
      this.sequencer.setHotspots(hotspots);
    }
    
    if (this.configPanel) {
      this.configPanel.setHotspot(null); // Clear selection on slide change
    }
  }
  
  /**
   * Sync sequencer with hotspots array
   * @param {Array} hotspots - Ordered hotspots array
   */
  syncSequencerWithHotspots(hotspots) {
    if (this.sequencer) {
      this.sequencer.setHotspots(hotspots);
    }
  }
  
  /**
   * Generate unique hotspot ID
   * @returns {string} Unique hotspot ID
   */
  generateHotspotId() {
    return `hotspot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  /**
   * Reorder hotspots after deletion
   */
  reorderHotspots() {
    if (!this.activeSlideId) return;
    
    const hotspots = this.getSlideHotspots(this.activeSlideId);
    hotspots.forEach((hotspot, index) => {
      hotspot.order = index;
    });
  }
  
  /**
   * Queue change for auto-save
   * @param {string} action - Action type
   * @param {Object} data - Change data
   * @param {Object} previousState - Previous state (for updates)
   */
  queueChange(action, data, previousState = null) {
    this.changeQueue.push({
      action,
      data,
      previousState,
      timestamp: Date.now()
    });
    
    if (this.options.autoSave) {
      this.processChangesDelayed();
    }
  }
  
  /**
   * Process pending changes with debouncing
   */
  processChangesDelayed() {
    if (this.processChangesTimeout) {
      clearTimeout(this.processChangesTimeout);
    }
    
    this.processChangesTimeout = setTimeout(() => {
      this.processPendingChanges();
    }, 1000); // 1 second debounce
  }
  
  /**
   * Process all pending changes
   */
  async processPendingChanges() {
    if (this.isProcessingChanges || this.changeQueue.length === 0) return;
    
    this.isProcessingChanges = true;
    
    try {
      await this.saveSlideHotspots();
    } catch (error) {
      console.error('Failed to process pending changes:', error);
    } finally {
      this.isProcessingChanges = false;
    }
  }
  
  /**
   * Debounced save for position changes
   * @param {string} hotspotId - Hotspot ID
   */
  debouncedSave(hotspotId) {
    if (this.debouncedSaveTimeouts) {
      clearTimeout(this.debouncedSaveTimeouts[hotspotId]);
    } else {
      this.debouncedSaveTimeouts = {};
    }
    
    this.debouncedSaveTimeouts[hotspotId] = setTimeout(() => {
      const hotspot = this.getHotspot(hotspotId);
      if (hotspot) {
        this.queueChange('update', hotspot);
      }
    }, 500); // 500ms debounce for position changes
  }
  
  /**
   * Set up auto-save functionality
   */
  setupAutoSave() {
    // Save on page unload
    window.addEventListener('beforeunload', () => {
      this.processPendingChanges();
    });
    
    // Periodic save every 30 seconds
    setInterval(() => {
      if (this.changeQueue.length > 0) {
        this.processPendingChanges();
      }
    }, 30000);
  }
  
  /**
   * Add event listener
   * @param {string} event - Event name
   * @param {Function} callback - Callback function
   */
  on(event, callback) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event).push(callback);
  }
  
  /**
   * Remove event listener
   * @param {string} event - Event name
   * @param {Function} callback - Callback function
   */
  off(event, callback) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }
  
  /**
   * Emit event to listeners
   * @param {string} event - Event name
   * @param {any} data - Event data
   */
  emit(event, data) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event listener for ${event}:`, error);
        }
      });
    }
  }
  
  /**
   * Get statistics about current hotspots
   * @returns {Object} Statistics
   */
  getStatistics() {
    const activeSlideHotspots = this.getSlideHotspots(this.activeSlideId || '');
    
    return {
      totalSlides: this.hotspots.size,
      activeSlide: this.activeSlideId,
      hotspotsInActiveSlide: activeSlideHotspots.length,
      selectedHotspot: this.selectedHotspotId,
      pendingChanges: this.changeQueue.length,
      maxHotspotsPerSlide: this.options.maxHotspots
    };
  }
  
  /**
   * Clear all data
   */
  clear() {
    this.hotspots.clear();
    this.activeSlideId = null;
    this.selectedHotspotId = null;
    this.changeQueue = [];
    this.clearTimeouts();
  }
  
  /**
   * Clear all timeouts
   */
  clearTimeouts() {
    if (this.processChangesTimeout) {
      clearTimeout(this.processChangesTimeout);
      this.processChangesTimeout = null;
    }
    
    if (this.debouncedSaveTimeouts) {
      Object.values(this.debouncedSaveTimeouts).forEach(timeout => {
        clearTimeout(timeout);
      });
      this.debouncedSaveTimeouts = {};
    }
  }
  
  /**
   * Destroy the hotspot manager
   */
  destroy() {
    this.processPendingChanges();
    this.clearTimeouts();
    this.clear();
    this.eventListeners.clear();
  }
}
</script>