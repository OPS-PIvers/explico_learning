<script>
/**
 * ProjectManager Service for Explico Learning
 * Orchestrates project-level operations and coordinates all other services
 */

class ProjectManager {
  
  constructor(options = {}) {
    this.options = {
      autoSave: true,
      maxProjects: 50,
      defaultThumbnailSize: { width: 240, height: 135 },
      ...options
    };
    
    this.currentProject = null;
    this.currentSlide = null;
    this.isInitialized = false;
    this.eventListeners = new Map();
    
    // Service instances
    this.sheetsAPI = null;
    this.hotspotManager = null;
    this.mediaHandler = null;
    this.eventTypeHandlers = null;
    
    // Component references (set by application)
    this.dashboard = null;
    this.header = null;
    this.sidebar = null;
    this.canvas = null;
    this.configPanel = null;
    this.sequencer = null;
  }
  
  /**
   * Initialize the project manager with services
   * @param {Object} services - Service instances
   * @returns {Promise<void>}
   */
  async initialize(services = {}) {
    try {
      // Initialize services
      this.sheetsAPI = services.sheetsAPI || new GoogleSheetsAPI();
      this.mediaHandler = services.mediaHandler || new MediaHandler();
      this.eventTypeHandlers = services.eventTypeHandlers || new EventTypeHandlers();
      this.hotspotManager = services.hotspotManager || new HotspotManager();
      
      // Initialize hotspot manager with dependencies
      this.hotspotManager.initialize({
        sheetsAPI: this.sheetsAPI,
        eventTypeHandlers: this.eventTypeHandlers
      });
      
      this.isInitialized = true;
      
      // Set up event listeners
      this.setupEventListeners();
      
      console.log('ProjectManager initialized successfully');
    } catch (error) {
      console.error('Failed to initialize ProjectManager:', error);
      throw error;
    }
  }
  
  /**
   * Set component references
   * @param {Object} components - Component instances
   */
  setComponents(components = {}) {
    this.dashboard = components.dashboard;
    this.header = components.header;
    this.sidebar = components.sidebar;
    this.canvas = components.canvas;
    this.configPanel = components.configPanel;
    this.sequencer = components.sequencer;
    
    // Pass components to hotspot manager
    if (this.hotspotManager) {
      this.hotspotManager.setComponents({
        canvas: this.canvas,
        configPanel: this.configPanel,
        sequencer: this.sequencer
      });
    }
    
    this.setupComponentEventHandlers();
  }
  
  /**
   * Setup component event handlers
   */
  setupComponentEventHandlers() {
    if (this.dashboard) {
      this.dashboard.options.onProjectSelect = (project) => this.openProject(project.id);
      this.dashboard.options.onProjectCreate = () => this.createNewProject();
      this.dashboard.options.onProjectEdit = (project) => this.openProject(project.id);
      this.dashboard.options.onProjectDelete = (project) => this.deleteProject(project.id);
      this.dashboard.options.onProjectDuplicate = (project) => this.duplicateProject(project.id);
    }
    
    if (this.header) {
      this.header.options.onSave = () => this.saveCurrentProject();
      this.header.options.onShare = () => this.shareCurrentProject();
    }
    
    if (this.sidebar) {
      this.sidebar.options.onSlideSelect = (slideId) => this.selectSlide(slideId);
      this.sidebar.options.onSlideAdd = () => this.createNewSlide();
      this.sidebar.options.onSlideDelete = (slideId) => this.deleteSlide(slideId);
      this.sidebar.options.onSlideReorder = (fromIndex, toIndex) => this.reorderSlides(fromIndex, toIndex);
    }
  }
  
  /**
   * Setup service event listeners
   */
  setupEventListeners() {
    if (this.hotspotManager) {
      this.hotspotManager.on('hotspotCreated', (hotspot) => {
        this.emit('hotspotCreated', hotspot);
        if (this.options.autoSave) {
          this.debouncedSave();
        }
      });
      
      this.hotspotManager.on('hotspotUpdated', (data) => {
        this.emit('hotspotUpdated', data);
        if (this.options.autoSave) {
          this.debouncedSave();
        }
      });
      
      this.hotspotManager.on('hotspotDeleted', (hotspot) => {
        this.emit('hotspotDeleted', hotspot);
        if (this.options.autoSave) {
          this.debouncedSave();
        }
      });
    }
  }
  
  /**
   * Create a new project
   * @param {Object} projectData - Initial project data
   * @returns {Promise<Object>} Created project
   */
  async createNewProject(projectData = {}) {
    this.ensureInitialized();
    
    const project = {
      ...PROJECT_DEFAULTS,
      name: projectData.name || 'New Walkthrough',
      description: projectData.description || '',
      createdBy: this.getCurrentUser(),
      ...projectData
    };
    
    try {
      // Create project in sheets
      const createdProject = await this.sheetsAPI.createProject(project);
      
      // Initialize spreadsheet for this project if needed
      if (!this.sheetsAPI.getSpreadsheetId()) {
        await this.sheetsAPI.initialize(createdProject.id);
      }
      
      // Create initial slide
      const initialSlide = await this.createSlide({
        projectId: createdProject.id,
        name: 'Slide 1',
        order: 0
      });
      
      createdProject.slides = [initialSlide];
      
      this.emit('projectCreated', createdProject);
      return createdProject;
    } catch (error) {
      console.error('Failed to create project:', error);
      throw error;
    }
  }
  
  /**
   * Open an existing project
   * @param {string} projectId - Project ID
   * @returns {Promise<Object>} Opened project
   */
  async openProject(projectId) {
    this.ensureInitialized();
    
    try {
      // Initialize sheets for this project
      await this.sheetsAPI.initialize(projectId);
      
      // Load project data
      const project = await this.sheetsAPI.getProject(projectId);
      if (!project) {
        throw new Error(`Project ${projectId} not found`);
      }
      
      // Load slides
      project.slides = await this.sheetsAPI.getSlidesByProject(projectId);
      
      // Set as current project
      this.currentProject = project;
      this.currentSlide = project.slides[0] || null;
      
      // Update components
      this.syncProjectToComponents();
      
      // Load hotspots for current slide
      if (this.currentSlide) {
        await this.selectSlide(this.currentSlide.id);
      }
      
      this.emit('projectOpened', project);
      return project;
    } catch (error) {
      console.error('Failed to open project:', error);
      throw error;
    }
  }
  
  /**
   * Save current project
   * @returns {Promise<boolean>} Success status
   */
  async saveCurrentProject() {
    if (!this.currentProject) {
      console.warn('No current project to save');
      return false;
    }
    
    try {
      // Update project timestamp
      this.currentProject.updatedAt = new Date().toISOString();
      
      // Save project
      await this.sheetsAPI.updateProject(this.currentProject.id, this.currentProject);
      
      // Save current slide hotspots
      if (this.currentSlide && this.hotspotManager) {
        await this.hotspotManager.saveSlideHotspots(this.currentSlide.id);
      }
      
      // Update header to show saved state
      if (this.header) {
        this.header.setDirty(false);
      }
      
      this.emit('projectSaved', this.currentProject);
      return true;
    } catch (error) {
      console.error('Failed to save project:', error);
      this.emit('projectSaveError', error);
      return false;
    }
  }
  
  /**
   * Delete a project
   * @param {string} projectId - Project ID
   * @returns {Promise<boolean>} Success status
   */
  async deleteProject(projectId) {
    this.ensureInitialized();
    
    try {
      await this.sheetsAPI.deleteProject(projectId);
      
      // If this was the current project, clear it
      if (this.currentProject && this.currentProject.id === projectId) {
        this.currentProject = null;
        this.currentSlide = null;
        this.clearComponents();
      }
      
      this.emit('projectDeleted', projectId);
      return true;
    } catch (error) {
      console.error('Failed to delete project:', error);
      throw error;
    }
  }
  
  /**
   * Duplicate a project
   * @param {string} projectId - Project ID to duplicate
   * @returns {Promise<Object>} Duplicated project
   */
  async duplicateProject(projectId) {
    this.ensureInitialized();
    
    try {
      // Load original project
      const originalProject = await this.sheetsAPI.getProject(projectId);
      if (!originalProject) {
        throw new Error(`Project ${projectId} not found`);
      }
      
      // Create new project
      const duplicatedProject = await this.createNewProject({
        ...originalProject,
        name: `${originalProject.name} (Copy)`,
        id: undefined, // Will be generated
        createdAt: undefined,
        updatedAt: undefined
      });
      
      // Load and duplicate slides
      const originalSlides = await this.sheetsAPI.getSlidesByProject(projectId);
      for (const slide of originalSlides) {
        const duplicatedSlide = await this.createSlide({
          ...slide,
          id: undefined,
          projectId: duplicatedProject.id,
          createdAt: undefined,
          updatedAt: undefined
        });
        
        // Load and duplicate hotspots
        const originalHotspots = await this.sheetsAPI.getHotspotsBySlide(slide.id);
        const duplicatedHotspots = originalHotspots.map(hotspot => ({
          ...hotspot,
          id: undefined,
          slideId: duplicatedSlide.id,
          createdAt: undefined,
          updatedAt: undefined
        }));
        
        if (duplicatedHotspots.length > 0) {
          await this.sheetsAPI.saveHotspots(duplicatedHotspots);
        }
      }
      
      this.emit('projectDuplicated', { original: originalProject, duplicate: duplicatedProject });
      return duplicatedProject;
    } catch (error) {
      console.error('Failed to duplicate project:', error);
      throw error;
    }
  }
  
  /**
   * Get all projects
   * @returns {Promise<Array<Object>>} Array of projects
   */
  async getAllProjects() {
    this.ensureInitialized();
    
    try {
      const projects = await this.sheetsAPI.getAllProjects();
      
      // Calculate analytics for each project
      for (const project of projects) {
        project.analytics = await this.calculateProjectAnalytics(project.id);
      }
      
      return projects;
    } catch (error) {
      console.error('Failed to get all projects:', error);
      throw error;
    }
  }
  
  /**
   * Create a new slide
   * @param {Object} slideData - Slide data
   * @returns {Promise<Object>} Created slide
   */
  async createSlide(slideData = {}) {
    if (!this.currentProject && !slideData.projectId) {
      throw new Error('No current project or project ID provided');
    }
    
    const slide = {
      ...SLIDE_DEFAULTS,
      projectId: slideData.projectId || this.currentProject.id,
      name: slideData.name || `Slide ${(this.currentProject?.slides?.length || 0) + 1}`,
      order: slideData.order !== undefined ? slideData.order : (this.currentProject?.slides?.length || 0),
      ...slideData
    };
    
    try {
      const createdSlide = await this.sheetsAPI.createSlide(slide);
      
      // Add to current project if it's loaded
      if (this.currentProject && createdSlide.projectId === this.currentProject.id) {
        this.currentProject.slides = this.currentProject.slides || [];
        this.currentProject.slides.push(createdSlide);
        this.syncSlidesToSidebar();
      }
      
      this.emit('slideCreated', createdSlide);
      return createdSlide;
    } catch (error) {
      console.error('Failed to create slide:', error);
      throw error;
    }
  }
  
  /**
   * Select a slide
   * @param {string} slideId - Slide ID
   * @returns {Promise<Object>} Selected slide
   */
  async selectSlide(slideId) {
    if (!this.currentProject) {
      throw new Error('No current project loaded');
    }
    
    const slide = this.currentProject.slides.find(s => s.id === slideId);
    if (!slide) {
      throw new Error(`Slide ${slideId} not found`);
    }
    
    try {
      this.currentSlide = slide;
      
      // Update hotspot manager
      if (this.hotspotManager) {
        this.hotspotManager.setActiveSlide(slideId);
        await this.hotspotManager.loadSlideHotspots(slideId);
      }
      
      // Update canvas background
      if (this.canvas) {
        await this.updateCanvasBackground(slide);
      }
      
      // Update sidebar selection
      if (this.sidebar) {
        this.sidebar.selectSlide(slideId);
      }
      
      this.emit('slideSelected', slide);
      return slide;
    } catch (error) {
      console.error('Failed to select slide:', error);
      throw error;
    }
  }
  
  /**
   * Delete a slide
   * @param {string} slideId - Slide ID
   * @returns {Promise<boolean>} Success status
   */
  async deleteSlide(slideId) {
    if (!this.currentProject) {
      throw new Error('No current project loaded');
    }
    
    try {
      // Delete hotspots first
      await this.sheetsAPI.deleteHotspotsBySlide(slideId);
      
      // Delete slide
      await this.sheetsAPI.deleteRowById(SHEETS_CONFIG.SLIDES_SHEET, slideId);
      
      // Remove from current project
      this.currentProject.slides = this.currentProject.slides.filter(s => s.id !== slideId);
      
      // If this was the current slide, select another
      if (this.currentSlide && this.currentSlide.id === slideId) {
        const nextSlide = this.currentProject.slides[0];
        if (nextSlide) {
          await this.selectSlide(nextSlide.id);
        } else {
          this.currentSlide = null;
          this.clearCanvas();
        }
      }
      
      // Update sidebar
      this.syncSlidesToSidebar();
      
      this.emit('slideDeleted', slideId);
      return true;
    } catch (error) {
      console.error('Failed to delete slide:', error);
      throw error;
    }
  }
  
  /**
   * Update slide background
   * @param {string} slideId - Slide ID
   * @param {string} backgroundUrl - Background URL
   * @param {string} backgroundType - Background type
   * @returns {Promise<Object>} Updated slide
   */
  async updateSlideBackground(slideId, backgroundUrl, backgroundType) {
    try {
      // Process media URL
      const mediaInfo = await this.mediaHandler.processMediaUrl(backgroundUrl);
      if (!mediaInfo.isValid) {
        throw new Error(mediaInfo.error || 'Invalid media URL');
      }
      
      // Update slide
      const updatedSlide = await this.sheetsAPI.updateSlide(slideId, {
        backgroundUrl: backgroundUrl,
        backgroundType: backgroundType || mediaInfo.type
      });
      
      // Update current project data
      if (this.currentProject) {
        const slideIndex = this.currentProject.slides.findIndex(s => s.id === slideId);
        if (slideIndex !== -1) {
          this.currentProject.slides[slideIndex] = updatedSlide;
        }
      }
      
      // Update canvas if this is the current slide
      if (this.currentSlide && this.currentSlide.id === slideId) {
        this.currentSlide = updatedSlide;
        await this.updateCanvasBackground(updatedSlide);
      }
      
      // Update sidebar thumbnails
      this.syncSlidesToSidebar();
      
      this.emit('slideBackgroundUpdated', updatedSlide);
      return updatedSlide;
    } catch (error) {
      console.error('Failed to update slide background:', error);
      throw error;
    }
  }
  
  /**
   * Update canvas background
   * @param {Object} slide - Slide data
   */
  async updateCanvasBackground(slide) {
    if (!this.canvas || !slide.backgroundUrl) return;
    
    try {
      this.canvas.setBackground(slide.backgroundUrl, slide.backgroundType);
    } catch (error) {
      console.error('Failed to update canvas background:', error);
    }
  }
  
  /**
   * Reorder slides
   * @param {number} fromIndex - Source index
   * @param {number} toIndex - Target index
   * @returns {Promise<boolean>} Success status
   */
  async reorderSlides(fromIndex, toIndex) {
    if (!this.currentProject || !this.currentProject.slides) {
      return false;
    }
    
    try {
      const slides = [...this.currentProject.slides];
      const [movedSlide] = slides.splice(fromIndex, 1);
      slides.splice(toIndex, 0, movedSlide);
      
      // Update order values and save
      for (let i = 0; i < slides.length; i++) {
        slides[i].order = i;
        await this.sheetsAPI.updateSlide(slides[i].id, { order: i });
      }
      
      this.currentProject.slides = slides;
      this.syncSlidesToSidebar();
      
      this.emit('slidesReordered', { fromIndex, toIndex, slides });
      return true;
    } catch (error) {
      console.error('Failed to reorder slides:', error);
      throw error;
    }
  }
  
  /**
   * Calculate project analytics
   * @param {string} projectId - Project ID
   * @returns {Promise<Object>} Analytics data
   */
  async calculateProjectAnalytics(projectId) {
    try {
      const analytics = await this.sheetsAPI.getAnalytics(projectId);
      
      // Basic calculations
      const views = analytics.filter(a => a.eventType === 'view').length;
      const completions = analytics.filter(a => a.eventType === 'complete').length;
      const completionRate = views > 0 ? (completions / views) * 100 : 0;
      
      return {
        views: views,
        completionRate: Math.round(completionRate),
        averageTime: 0, // TODO: Calculate from analytics
        lastViewed: analytics.length > 0 ? analytics[0].timestamp : null
      };
    } catch (error) {
      console.error('Failed to calculate analytics:', error);
      return {
        views: 0,
        completionRate: 0,
        averageTime: 0,
        lastViewed: null
      };
    }
  }
  
  /**
   * Share current project
   */
  shareCurrentProject() {
    if (!this.currentProject) {
      console.warn('No current project to share');
      return;
    }
    
    // TODO: Implement sharing functionality
    console.log('Sharing project:', this.currentProject.id);
    this.emit('projectShared', this.currentProject);
  }
  
  /**
   * Export current project
   * @param {string} format - Export format
   * @returns {Promise<Blob|string>} Exported data
   */
  async exportProject(format = 'json') {
    if (!this.currentProject) {
      throw new Error('No current project to export');
    }
    
    try {
      // Load complete project data
      const projectData = {
        project: this.currentProject,
        slides: await this.sheetsAPI.getSlidesByProject(this.currentProject.id),
        hotspots: {}
      };
      
      // Load hotspots for each slide
      for (const slide of projectData.slides) {
        projectData.hotspots[slide.id] = await this.sheetsAPI.getHotspotsBySlide(slide.id);
      }
      
      switch (format.toLowerCase()) {
        case 'json':
          return new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
        
        default:
          throw new Error(`Unsupported export format: ${format}`);
      }
    } catch (error) {
      console.error('Failed to export project:', error);
      throw error;
    }
  }
  
  /**
   * Import project from data
   * @param {Object} projectData - Project data
   * @returns {Promise<Object>} Imported project
   */
  async importProject(projectData) {
    try {
      // Create new project
      const newProject = await this.createNewProject({
        ...projectData.project,
        id: undefined,
        name: `${projectData.project.name} (Imported)`
      });
      
      // Import slides
      for (const slide of projectData.slides || []) {
        const newSlide = await this.createSlide({
          ...slide,
          id: undefined,
          projectId: newProject.id
        });
        
        // Import hotspots for this slide
        const slideHotspots = projectData.hotspots[slide.id] || [];
        if (slideHotspots.length > 0) {
          const newHotspots = slideHotspots.map(hotspot => ({
            ...hotspot,
            id: undefined,
            slideId: newSlide.id
          }));
          
          await this.sheetsAPI.saveHotspots(newHotspots);
        }
      }
      
      this.emit('projectImported', newProject);
      return newProject;
    } catch (error) {
      console.error('Failed to import project:', error);
      throw error;
    }
  }
  
  /**
   * Sync project data to components
   */
  syncProjectToComponents() {
    if (!this.currentProject) return;
    
    // Update header
    if (this.header) {
      this.header.setTitle(this.currentProject.name);
    }
    
    // Update sidebar with slides
    this.syncSlidesToSidebar();
  }
  
  /**
   * Sync slides to sidebar
   */
  syncSlidesToSidebar() {
    if (!this.sidebar || !this.currentProject) return;
    
    this.sidebar.setSlides(this.currentProject.slides || []);
  }
  
  /**
   * Clear all components
   */
  clearComponents() {
    if (this.canvas) {
      this.canvas.clearHotspots();
      this.canvas.setBackground('', MEDIA_TYPES.IMAGE);
    }
    
    if (this.sidebar) {
      this.sidebar.setSlides([]);
    }
    
    if (this.configPanel) {
      this.configPanel.setHotspot(null);
    }
    
    if (this.sequencer) {
      this.sequencer.setHotspots([]);
    }
  }
  
  /**
   * Clear canvas only
   */
  clearCanvas() {
    if (this.canvas) {
      this.canvas.clearHotspots();
      this.canvas.setBackground('', MEDIA_TYPES.IMAGE);
    }
  }
  
  /**
   * Get current user (placeholder)
   * @returns {string} Current user ID
   */
  getCurrentUser() {
    // TODO: Integrate with Google Apps Script user system
    return Session.getActiveUser().getEmail();
  }
  
  /**
   * Debounced save function
   */
  debouncedSave() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    
    this.saveTimeout = setTimeout(() => {
      this.saveCurrentProject();
    }, 2000);
  }
  
  /**
   * Add event listener
   * @param {string} event - Event name
   * @param {Function} callback - Callback function
   */
  on(event, callback) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event).push(callback);
  }
  
  /**
   * Remove event listener
   * @param {string} event - Event name
   * @param {Function} callback - Callback function
   */
  off(event, callback) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }
  
  /**
   * Emit event to listeners
   * @param {string} event - Event name
   * @param {any} data - Event data
   */
  emit(event, data) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event listener for ${event}:`, error);
        }
      });
    }
  }
  
  /**
   * Ensure the service is initialized
   * @throws {Error} If not initialized
   */
  ensureInitialized() {
    if (!this.isInitialized) {
      throw new Error('ProjectManager not initialized. Call initialize() first.');
    }
  }
  
  /**
   * Get current project
   * @returns {Object|null} Current project
   */
  getCurrentProject() {
    return this.currentProject;
  }
  
  /**
   * Get current slide
   * @returns {Object|null} Current slide
   */
  getCurrentSlide() {
    return this.currentSlide;
  }
  
  /**
   * Get service statistics
   * @returns {Object} Service statistics
   */
  getStats() {
    return {
      initialized: this.isInitialized,
      currentProject: this.currentProject?.id || null,
      currentSlide: this.currentSlide?.id || null,
      hotspotManagerStats: this.hotspotManager?.getStatistics() || null,
      mediaHandlerStats: this.mediaHandler?.getCacheStats() || null,
      sheetsAPIStats: this.sheetsAPI?.getStats() || null
    };
  }
  
  /**
   * Destroy the project manager
   */
  destroy() {
    // Clear timeouts
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    
    // Destroy services
    if (this.hotspotManager) {
      this.hotspotManager.destroy();
    }
    
    if (this.mediaHandler) {
      this.mediaHandler.destroy();
    }
    
    if (this.eventTypeHandlers) {
      this.eventTypeHandlers.destroy();
    }
    
    if (this.sheetsAPI) {
      this.sheetsAPI.destroy();
    }
    
    // Clear state
    this.currentProject = null;
    this.currentSlide = null;
    this.isInitialized = false;
    this.eventListeners.clear();
  }
}
</script>