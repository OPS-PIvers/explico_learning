<script>
/**
 * ConfigPanel Component for Explico Learning
 * Configuration panel for hotspot settings and properties
 */

class ConfigPanel {
  
  constructor(options = {}) {
    this.options = {
      title: 'Hotspot Configuration',
      hotspot: null,
      onConfigChange: null,
      onConfigSave: null,
      ...options
    };
    
    this.element = null;
    this.formElements = new Map();
    this.isDirty = false;
  }
  
  /**
   * Create and return the config panel element
   * @returns {HTMLElement} Config panel element
   */
  render() {
    this.element = document.createElement('aside');
    this.element.className = 'config-panel flex flex-col gap-4 rounded-lg bg-[#1f2937] p-4 overflow-y-auto';
    this.element.style.width = `${UI_CONFIG.CONFIG_PANEL_WIDTH}px`;
    
    // Header
    const header = this.createHeader();
    this.element.appendChild(header);
    
    // Configuration form
    const form = this.createConfigForm();
    this.element.appendChild(form);
    
    return this.element;
  }
  
  /**
   * Create panel header
   * @returns {HTMLElement} Header element
   */
  createHeader() {
    const header = document.createElement('div');
    header.className = 'config-header flex items-center justify-between';
    
    const title = document.createElement('h2');
    title.className = 'text-white text-lg font-semibold px-2';
    title.textContent = this.options.title;
    
    header.appendChild(title);
    
    return header;
  }
  
  /**
   * Create configuration form
   * @returns {HTMLElement} Form container element
   */
  createConfigForm() {
    const container = document.createElement('div');
    container.className = 'config-form flex flex-col gap-4';
    container.id = 'config-form';
    
    if (this.options.hotspot) {
      this.renderHotspotConfig(container);
    } else {
      this.renderEmptyState(container);
    }
    
    return container;
  }
  
  /**
   * Render empty state when no hotspot is selected
   * @param {HTMLElement} container - Container element
   */
  renderEmptyState(container) {
    const emptyState = document.createElement('div');
    emptyState.className = 'empty-state flex flex-col items-center justify-center py-12 text-center';
    
    const icon = document.createElement('span');
    icon.className = 'material-symbols-outlined text-4xl text-gray-500 mb-4';
    icon.textContent = 'touch_app';
    
    const title = document.createElement('h3');
    title.className = 'text-lg font-medium text-gray-300 mb-2';
    title.textContent = 'No Hotspot Selected';
    
    const description = document.createElement('p');
    description.className = 'text-sm text-gray-400';
    description.textContent = 'Select a hotspot to configure its properties, or create a new one.';
    
    emptyState.appendChild(icon);
    emptyState.appendChild(title);
    emptyState.appendChild(description);
    container.appendChild(emptyState);
  }
  
  /**
   * Render hotspot configuration form
   * @param {HTMLElement} container - Container element
   */
  renderHotspotConfig(container) {
    const config = this.options.hotspot;
    
    // Clear container
    container.innerHTML = '';
    
    // Basic Properties
    const basicSection = this.createSection('Basic Properties');
    container.appendChild(basicSection);
    
    // Hotspot Name
    const nameInput = FormControls.createTextInput({
      id: 'hotspot-name',
      label: 'Hotspot Name',
      value: config.name || '',
      maxLength: VALIDATION_RULES.HOTSPOT_NAME.maxLength,
      onChange: (value) => this.updateConfig('name', value)
    });
    this.formElements.set('name', nameInput);
    basicSection.appendChild(nameInput);
    
    // Styling Section
    const stylingSection = this.createSection('Styling');
    container.appendChild(stylingSection);
    
    // Color and Size row
    const colorSizeRow = document.createElement('div');
    colorSizeRow.className = 'grid grid-cols-2 gap-2';
    
    // Hotspot Color
    const colorInput = FormControls.createColorInput({
      id: 'hotspot-color',
      label: 'Color',
      value: config.color || HOTSPOT_DEFAULTS.color,
      onChange: (value) => this.updateConfig('color', value)
    });
    this.formElements.set('color', colorInput);
    colorSizeRow.appendChild(colorInput);
    
    // Hotspot Size
    const sizeInput = FormControls.createNumberInput({
      id: 'hotspot-size',
      label: 'Size (px)',
      value: config.size || HOTSPOT_DEFAULTS.size,
      min: 16,
      max: 100,
      onChange: (value) => this.updateConfig('size', value)
    });
    this.formElements.set('size', sizeInput);
    colorSizeRow.appendChild(sizeInput);
    
    stylingSection.appendChild(colorSizeRow);
    
    // Pulse Animation Toggle
    const pulseToggle = FormControls.createToggle({
      id: 'pulse-animation',
      label: 'Pulse Animation',
      checked: config.pulseAnimation ?? HOTSPOT_DEFAULTS.pulseAnimation,
      onChange: (value) => this.updateConfig('pulseAnimation', value)
    });
    this.formElements.set('pulseAnimation', pulseToggle);
    stylingSection.appendChild(pulseToggle);
    
    // Event Trigger Section
    const triggerSection = this.createSection('Event Trigger');
    container.appendChild(triggerSection);
    
    // Trigger Type Buttons
    const triggerButtons = FormControls.createButtonGroup({
      id: 'trigger-type',
      label: 'Trigger Type',
      value: config.triggerType || HOTSPOT_DEFAULTS.triggerType,
      buttons: [
        { value: TRIGGER_TYPES.CLICK, label: 'On Click' },
        { value: TRIGGER_TYPES.TOUCH, label: 'On Touch' },
        { value: TRIGGER_TYPES.HOVER, label: 'On Hover' }
      ],
      onChange: (value) => this.updateConfig('triggerType', value)
    });
    this.formElements.set('triggerType', triggerButtons);
    triggerSection.appendChild(triggerButtons);
    
    // Event Type Section
    const eventSection = this.createSection('Event Configuration');
    container.appendChild(eventSection);
    
    // Event Type Select
    const eventTypeSelect = FormControls.createSelect({
      id: 'event-type',
      label: 'Event Type',
      value: config.eventType || HOTSPOT_DEFAULTS.eventType,
      options: [
        { value: EVENT_TYPES.TEXT_POPUP, label: 'Text Pop-up' },
        { value: EVENT_TYPES.TEXT_ON_IMAGE, label: 'Text on Image' },
        { value: EVENT_TYPES.PAN_ZOOM, label: 'Pan/Zoom to Hotspot' },
        { value: EVENT_TYPES.SPOTLIGHT, label: 'Spotlight' }
      ],
      onChange: (value) => {
        this.updateConfig('eventType', value);
        this.renderEventTypeConfig(eventSection, value);
      }
    });
    this.formElements.set('eventType', eventTypeSelect);
    eventSection.appendChild(eventTypeSelect);
    
    // Event Type Specific Configuration
    this.renderEventTypeConfig(eventSection, config.eventType || HOTSPOT_DEFAULTS.eventType);
  }
  
  /**
   * Render event type specific configuration
   * @param {HTMLElement} container - Event section container
   * @param {string} eventType - Event type
   */
  renderEventTypeConfig(container, eventType) {
    // Remove existing event config
    const existingConfig = container.querySelector('.event-config');
    if (existingConfig) {
      existingConfig.remove();
    }
    
    const eventConfig = document.createElement('div');
    eventConfig.className = 'event-config flex flex-col gap-4 p-2 border border-gray-700 rounded-lg';
    
    const config = this.options.hotspot;
    
    switch (eventType) {
      case EVENT_TYPES.TEXT_ON_IMAGE:
        this.renderTextOnImageConfig(eventConfig, config);
        break;
      case EVENT_TYPES.TEXT_POPUP:
        this.renderTextPopupConfig(eventConfig, config);
        break;
      case EVENT_TYPES.PAN_ZOOM:
        this.renderPanZoomConfig(eventConfig, config);
        break;
      case EVENT_TYPES.SPOTLIGHT:
        this.renderSpotlightConfig(eventConfig, config);
        break;
    }
    
    container.appendChild(eventConfig);
  }
  
  /**
   * Render text on image configuration
   * @param {HTMLElement} container - Container element
   * @param {Object} config - Hotspot configuration
   */
  renderTextOnImageConfig(container, config) {
    // Tooltip Content
    const contentInput = FormControls.createTextarea({
      id: 'tooltip-content',
      label: 'Tooltip Content',
      value: config.tooltipContent || '',
      placeholder: 'Enter tooltip text',
      maxLength: VALIDATION_RULES.TOOLTIP_CONTENT.maxLength,
      onChange: (value) => this.updateConfig('tooltipContent', value)
    });
    this.formElements.set('tooltipContent', contentInput);
    container.appendChild(contentInput);
    
    // Tooltip Position
    const positionSelect = FormControls.createSelect({
      id: 'tooltip-position',
      label: 'Tooltip Position',
      value: config.tooltipPosition || TOOLTIP_POSITIONS.BOTTOM,
      options: [
        { value: TOOLTIP_POSITIONS.TOP, label: 'Top' },
        { value: TOOLTIP_POSITIONS.BOTTOM, label: 'Bottom' },
        { value: TOOLTIP_POSITIONS.LEFT, label: 'Left' },
        { value: TOOLTIP_POSITIONS.RIGHT, label: 'Right' }
      ],
      onChange: (value) => this.updateConfig('tooltipPosition', value)
    });
    this.formElements.set('tooltipPosition', positionSelect);
    container.appendChild(positionSelect);
  }
  
  /**
   * Render text popup configuration
   * @param {HTMLElement} container - Container element
   * @param {Object} config - Hotspot configuration
   */
  renderTextPopupConfig(container, config) {
    // Similar to text on image but with different styling options
    this.renderTextOnImageConfig(container, config);
  }
  
  /**
   * Render pan/zoom configuration
   * @param {HTMLElement} container - Container element
   * @param {Object} config - Hotspot configuration
   */
  renderPanZoomConfig(container, config) {
    // Zoom Level Slider
    const zoomSlider = FormControls.createSlider({
      id: 'zoom-level',
      label: 'Zoom Level',
      value: config.zoomLevel || 1.5,
      min: 1,
      max: 5,
      step: 0.1,
      showValue: true,
      valueFormatter: (value) => `${value}x`,
      onChange: (value) => this.updateConfig('zoomLevel', value)
    });
    this.formElements.set('zoomLevel', zoomSlider);
    container.appendChild(zoomSlider);
    
    // Banner Overlay
    const bannerInput = FormControls.createTextInput({
      id: 'banner-overlay',
      label: 'Banner Overlay (optional)',
      value: config.bannerText || '',
      placeholder: 'Enter banner text',
      maxLength: VALIDATION_RULES.BANNER_TEXT.maxLength,
      onChange: (value) => this.updateConfig('bannerText', value)
    });
    this.formElements.set('bannerText', bannerInput);
    container.appendChild(bannerInput);
  }
  
  /**
   * Render spotlight configuration
   * @param {HTMLElement} container - Container element
   * @param {Object} config - Hotspot configuration
   */
  renderSpotlightConfig(container, config) {
    // Spotlight Size
    const sizeSlider = FormControls.createSlider({
      id: 'spotlight-size',
      label: 'Spotlight Size',
      value: config.spotlightSize || 200,
      min: 50,
      max: 500,
      step: 10,
      showValue: true,
      valueFormatter: (value) => `${value}px`,
      onChange: (value) => this.updateConfig('spotlightSize', value)
    });
    this.formElements.set('spotlightSize', sizeSlider);
    container.appendChild(sizeSlider);
    
    // Spotlight Intensity
    const intensitySlider = FormControls.createSlider({
      id: 'spotlight-intensity',
      label: 'Spotlight Intensity',
      value: config.spotlightIntensity || 0.8,
      min: 0.1,
      max: 1,
      step: 0.1,
      showValue: true,
      valueFormatter: (value) => `${Math.round(value * 100)}%`,
      onChange: (value) => this.updateConfig('spotlightIntensity', value)
    });
    this.formElements.set('spotlightIntensity', intensitySlider);
    container.appendChild(intensitySlider);
  }
  
  /**
   * Create a configuration section
   * @param {string} title - Section title
   * @returns {HTMLElement} Section element
   */
  createSection(title) {
    const section = document.createElement('div');
    section.className = 'config-section flex flex-col gap-3';
    
    const header = document.createElement('h3');
    header.className = 'text-sm font-medium text-gray-300 px-2';
    header.textContent = title;
    
    section.appendChild(header);
    
    return section;
  }
  
  /**
   * Update hotspot configuration
   * @param {string} property - Property name
   * @param {any} value - New value
   */
  updateConfig(property, value) {
    if (!this.options.hotspot) return;
    
    // Update local config
    this.options.hotspot[property] = value;
    this.isDirty = true;
    
    // Trigger change callback
    if (this.options.onConfigChange) {
      this.options.onConfigChange(property, value, this.options.hotspot);
    }
  }
  
  /**
   * Set hotspot configuration
   * @param {Object} hotspot - Hotspot configuration
   */
  setHotspot(hotspot) {
    this.options.hotspot = hotspot;
    this.isDirty = false;
    
    // Re-render the form
    const form = this.element?.querySelector('#config-form');
    if (form) {
      if (hotspot) {
        this.renderHotspotConfig(form);
      } else {
        this.renderEmptyState(form);
      }
    }
  }
  
  /**
   * Get current hotspot configuration
   * @returns {Object|null} Hotspot configuration
   */
  getHotspot() {
    return this.options.hotspot;
  }
  
  /**
   * Validate current configuration
   * @returns {Object} Validation result
   */
  validateConfig() {
    if (!this.options.hotspot) {
      return { isValid: true, errors: [] };
    }
    
    const errors = [];
    const config = this.options.hotspot;
    
    // Validate name
    if (!config.name || config.name.trim().length === 0) {
      errors.push('Hotspot name is required');
    }
    
    // Validate tooltip content for text events
    if ((config.eventType === EVENT_TYPES.TEXT_ON_IMAGE || config.eventType === EVENT_TYPES.TEXT_POPUP) && 
        (!config.tooltipContent || config.tooltipContent.trim().length === 0)) {
      errors.push('Tooltip content is required for text events');
    }
    
    // Validate zoom level for pan/zoom events
    if (config.eventType === EVENT_TYPES.PAN_ZOOM && 
        (config.zoomLevel < 1 || config.zoomLevel > 5)) {
      errors.push('Zoom level must be between 1 and 5');
    }
    
    return {
      isValid: errors.length === 0,
      errors: errors
    };
  }
  
  /**
   * Save configuration
   * @returns {Promise<boolean>} Whether save was successful
   */
  async saveConfig() {
    const validation = this.validateConfig();
    if (!validation.isValid) {
      console.error('Configuration validation failed:', validation.errors);
      return false;
    }
    
    try {
      if (this.options.onConfigSave) {
        await this.options.onConfigSave(this.options.hotspot);
      }
      
      this.isDirty = false;
      return true;
    } catch (error) {
      console.error('Failed to save configuration:', error);
      return false;
    }
  }
  
  /**
   * Reset configuration to defaults
   */
  resetConfig() {
    if (!this.options.hotspot) return;
    
    // Reset to defaults while preserving ID and position
    const { id, position } = this.options.hotspot;
    this.options.hotspot = {
      ...HOTSPOT_DEFAULTS,
      id,
      position
    };
    
    // Re-render form
    this.setHotspot(this.options.hotspot);
    
    // Mark as dirty
    this.isDirty = true;
    
    // Trigger change callback
    if (this.options.onConfigChange) {
      this.options.onConfigChange('reset', null, this.options.hotspot);
    }
  }
  
  /**
   * Check if configuration has unsaved changes
   * @returns {boolean} Whether configuration is dirty
   */
  isDirty() {
    return this.isDirty;
  }
  
  /**
   * Show validation errors
   * @param {Array} errors - Array of error messages
   */
  showValidationErrors(errors) {
    // Remove existing error display
    const existingErrors = this.element?.querySelector('.validation-errors');
    if (existingErrors) {
      existingErrors.remove();
    }
    
    if (errors.length === 0) return;
    
    // Create error display
    const errorContainer = document.createElement('div');
    errorContainer.className = 'validation-errors bg-red-900/20 border border-red-500 rounded-md p-3 mb-4';
    
    const errorList = document.createElement('ul');
    errorList.className = 'text-red-400 text-sm list-disc list-inside';
    
    errors.forEach(error => {
      const errorItem = document.createElement('li');
      errorItem.textContent = error;
      errorList.appendChild(errorItem);
    });
    
    errorContainer.appendChild(errorList);
    
    // Insert at top of form
    const form = this.element?.querySelector('#config-form');
    if (form) {
      form.insertBefore(errorContainer, form.firstChild);
    }
  }
  
  /**
   * Clear validation errors
   */
  clearValidationErrors() {
    const existingErrors = this.element?.querySelector('.validation-errors');
    if (existingErrors) {
      existingErrors.remove();
    }
  }
  
  /**
   * Destroy the component
   */
  destroy() {
    this.formElements.clear();
    
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  }
  
  /**
   * Get config panel element
   * @returns {HTMLElement|null} Config panel element
   */
  getElement() {
    return this.element;
  }
}
</script>